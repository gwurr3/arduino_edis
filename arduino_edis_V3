#include <math.h>
// edis controller code.
// Strategy is to make a 2d array, one being rpm, the other being tps, with no hard-coded rpm or tps 
//   information, just a slope/offset/digitization into each one.  (maybe compute as a 0-1 function, 
//   then multiply by the number of rows and columns, then turn into an integer and read that row or column.)

// (ford edis) pip is every tooth, so 36 times per revolution.  At 6000 rpm, that's 3600 pulses per second.
// Measured interval in milliseconds will range from 120mS for 500 rpm to 6mS for 10,000 rpm. 

// program continuously reads throttle position.  When a negative interrupt from tach is caught, store microseconds, 
//  then the array number (which is the pause time in microseconds) is retrieved.  Pin set high, 
//  delay for required edis signal pause time, pin set low, exit interrupt.  This is blocking but
//  as it should exit far before next interrupt, and timer counter is separate hardware, it should
//  not block anything.

// SAW ranges from 64 to 1792 microseconds with max resolution of 4 microseconds.  That's 432 steps.  
//    If I use 8 microsecond resolution I can just use ints to store my table (although I have so much 
//    space I could use longs.)
//    I would have to multiply the result by four if I go with ints.  If I go with longs I get to use 
//    all the resolution and don't have to multiply -- values would directly reflect the pause times.

// I could also store the degrees advance in the table, then multiply to generate the values, but why?  
//   I can back-calculate that if necessary.  It would make debug for other people easier.

// it is likely that the best way to store the table itself is in external rom.  For initial development probably
//  stored in external flash or eeprom.

/* 
rpm  interrupts	 seconds         micros      linearized (=rpm/500)
500	18000	5.55556E-05	55.55555556	1
1000	36000	2.77778E-05	27.77777778	2
1500	54000	1.85185E-05	18.51851852	3
2000	72000	1.38889E-05	13.88888889	4
2500	90000	1.11111E-05	11.11111111	5
3000	108000	9.25926E-06	9.259259259	6
3500	126000	7.93651E-06	7.936507937	7
4000	144000	6.94444E-06	6.944444444	8
4500	162000	6.17284E-06	6.172839506	9
5000	180000	5.55556E-06	5.555555556	10
5500	198000	5.05051E-06	5.050505051	11
6000	216000	4.62963E-06	4.62962963	12
6500	234000	4.2735E-06	4.273504274	13
7000	252000	3.96825E-06	3.968253968	14
7500	270000	3.7037E-06	3.703703704	15
8000	288000	3.47222E-06	3.472222222	16
8500	306000	3.26797E-06	3.267973856	17
9000	324000	3.08642E-06	3.086419753	18
9500	342000	2.92398E-06	2.923976608	19
10000	360000	2.77778E-06	2.777777778	20
*/
// alternatively, for every 200 rpm from 200 up to 10K, (5000/36)*PIP

#include <AS5040.h>  // code for austrian microsystems magnetic rotary encoder for reading throttle position
AS5040 myAS5040(2,3,4);

volatile float PIP_period;    // microseconds between interrupts, ranges from 55 down to 2.777, needs lots of digits.
volatile long microseconds;  // time between PIP signals
volatile long throttle_position;   // rotary encoder on throttle
int output_pin = 1;          // SAW output
int debug = 1;

void setup()
{
  attachInterrupt(0, count_interrupt, FALLING); // this implicitly sets the pin for interrupt0 to input
  pinMode(output_pin, OUTPUT);  // trigger signal to edis module
  if(debug)
  {
    Serial.begin(9600);  // serial output completely slays any real-time performance
  }
}

void count_interrupt()
{    // this is a blocking function, but as long as time is called it should be able to recover
  int delaytime;
  PIP_period = micros() - microseconds;
  microseconds = micros();
  delaytime = lookup_delay(PIP_period, throttle_position); // call lookup table
  digitalWrite(output_pin, HIGH);                          // this is arguably an ugly way of doing this.
  delayMicroseconds(delaytime);                            //  may be better to set up a hardware pwm as a single-shot
  digitalWrite(output_pin, LOW);
}

int lookup_delay(long PIP_period, int throttle_position)
{
  const int rowsize = 8;  // presumably this is rpm, should eventually be 20 for every 500 rpm
  const int columnsize = 3; // and this is throttle position, should be 1-100 (by 5? or 10?) for 0-full throttle.
  int advance[rowsize][columnsize] = {{10,11,12},{13,14,15},{16,17,18},{19,20,21},{22,23,24},{25,26,27},{28,29,30},{31,32,33}};
  int rows, columns;
  // this should use PIP_period in uS, ranging from 60 down to 2.5.  1/PIP will give a linear function.
  // for example, a linearizing function for 500-10,000 by 500's would be (1000/18)/uS, resulting in a 1-20 
  //  linear function -- see table above.
  rows = (int)((1000.0/18.0)/PIP_period);
  columns = throttle_position;
  if (rows < 0) rows = 0;
  if (rows > rowsize-1) rows = rowsize-1;
  if (columns > columnsize-1) columns = columnsize-1;
  if (columns < 0) columns = 0;    // these need to be changed to reflect the size of the array.
  return(advance[rows] [columns]);
}

int throttle_position_read()
{
  int angle; // nmeasured throttle angle
  int offset; // difference between min throttle angle and zero
  int scaling; // map throttle min/max to 0-100
  
  offset = 0; // this will need to be changed based on use -- could be programmed into the 5040's prom.
  scaling = 1; // this, too, will need to be changed
  
  angle = myAS5040.encoder_value(); // this is 1-4096, needs to be converted to a 0-to-100 value, probably.
  angle = (angle - offset) * scaling;
  return angle;
}

void loop()
{
  throttle_position = throttle_position_read();
}
